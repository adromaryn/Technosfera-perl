package Local::JSONParser;

use strict;
use warnings;
use 5.10.0;
use utf8;

use base qw(Exporter);
our @EXPORT_OK = qw( parse_json );
our @EXPORT = qw( parse_json );

sub str_escape($) {
  my $string = shift;
  $string =~ s/\\\\/\0/;
  $string =~ s/(?<=\\u[0-9a-fA-F]{4})/\}/;
  $string =~ s/\\u(?=[0-9a-fA-F]{4})/\\x\{/;
  $string =~ s/\\u(?=.{3}[^0-9a-fA-F]|.{2}[^0-9a-fA-F]|.[^0-9a-fA-F]|[^0-9a-fA-F])/\\\\u/;
  $string =~ s/\0/\\\\/;
  $string =~ s/@/\\@/;
  $string =~ s/%/\\%/;
  $string =~ s/\$/\\\$/;
  return $string;
}

sub parse_hash {
  my %res;
  my $str = shift;
  if (not $str =~ /^(?:\s*
                        (?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")
                        \s*:\s*
                        (
                          (?:[-\+]?\+?\d*?\.?\d*)
                          |
                          (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|"")
                          |
                          (\{
                            (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|""|[^"\{\}]|\{.*\})*
                          ?\})
                          |
                          (\[
                            (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|""|[^"\[\]]|\[.*\])*
                          \])
                        )
                    \s*,?)*\s*$/sx) {
    die "not a JSON: {$str}";
  }

  while ($str =~ /\s*(?:"(.*?(?:[^\\](?:\\\\)*))")
                       \s*:\s*
                       (
                         (?:[-\+]?\+?\d*?\.?\d*)
                         |
                         (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|"")
                         |
                         (\{
                           (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|""|[^"\{\}]|\{.*\})*
                         \})
                         |
                         (?:\[
                           (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|""|[^"\[\]]|\[.*\])*
                         \])
                       )
                       \s*(?=,.*|$)/gscx) {
    my $key = eval('"'.str_escape($1).'"');
    if ($2 =~ /^\s*(\".*?\")\s*$/s) {
      my $string = str_escape($1);
      $res{$key} = eval($string);
    } elsif ($2 =~ /^\s*([-\+]?\+?\d*?\.?\d*)\s*$/s) {
      $res{$key} = 0+$1;
    } elsif ($2 =~ /^\s*\{(.*?)\}\s*$/s) {
      $res{$key} = parse_hash($1);
    } elsif ($2 =~ /^\s*\[(.*?)\]\s*$/s) {
      $res{$key} = parse_array($1);
    }
  }
  return \%res;
}

sub parse_array {
  my @res;
  my $str = shift;
  if (not $str =~ /^(?:(?:
                          (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|"")
                          |
                          (?:[-\+]?\+?\d*?\.?\d*)
                          |
                          (?:\{
                            (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|""|[^"\{\}]|\{.*\})*
                          \})
                          |
                          (?:\[
                            (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|""|[^"\[\]]|\[.*\])*
                          \])
                       )\s*,?\s*)*?$/sx) {
    die "not a JSON: [$str]";
  }
  while ($str =~ /(
                    (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|"")
                    |
                    (?:[-\+]?\+?\d*?\.?\d*)
                    |
                    (?:\{
                      (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|""|[^"\{\}]|\{.*\})*
                    \})
                    |
                    (?:\[
                      (?:(?:"(?:[^"]|(?:(?:\\\\)*\\"))*?(?:[^\\](?:\\\\)*)")|""|[^"\[\]]|\[.*\])*
                    \]))
                  \s*(?:,|$)/gscx) {
    if ($1 eq "") {
      last;
    }
    if ($1 =~ /^\s*(\".*?\")\s*$/s) {
      my $string = str_escape($1);
      push @res, eval($string);
    } elsif ($1 =~ /^\s*([-\+]?\+?\d*?\.?\d*)\s*$/s) {
      push  @res, (0+$1);
    } elsif ($1 =~ /^\s*\{(.*?)\}\s*$/s) {
      push @res, parse_hash($1);
    } elsif ($1 =~ /^\s*\[(.*?)\]\s*$/s) {
      push @res, parse_array($1);
    }
  }
  return \@res;
}

sub parse_json {
	my $source = shift;

	use JSON::XS;
	# return JSON::XS->new->utf8->decode($source);
	if ($source =~ /^\s*\{(.*)\}\s*$/s){
    return parse_hash $1;
  } elsif($source =~ /^\s*\[(.*)\]\s*$/s){
    return parse_array $1;
  } else {
    die "not a JSON: $_";
  }
}

1;
